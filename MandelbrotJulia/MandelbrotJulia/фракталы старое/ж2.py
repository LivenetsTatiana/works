import numpy as np
import matplotlib.pyplot as plt

pmin, pmax, qmin, qmax = -1, 1, -1, 1
# пусть c = p + iq и p меняется в диапазоне от pmin до pmax,
# а q меняется в диапазоне от qmin до qmax

ppoints, qpoints = 400, 400
# число точек по горизонтали и вертикали
image = np.zeros((ppoints, qpoints))
max_iterations = 300
# максимальное количество итераций

infinity_border = 10
# image — это двумерный массив, в котором будет записана наша картинка
# по умолчанию он заполнен нулями

p, q = np.mgrid[pmin:pmax:(ppoints*1j), qmin:qmax:(qpoints*1j)]
# np.mgrid создаёт сетку значений p и q, ppoints*1j здесь означает
# что мы хотим получить ppoints точек — это такая магия

z = p + 1j*q
c = (-1.0+1j)*np.ones_like(z)
# теперь c и z — это двумерные матрицы

print(type(c))
for k in range(max_iterations):
    z = z**2 + c
    # Самая Главная Формула осталась без изменений
    # но в данном случае операции производятся с матрицами
    # и действуют поэлементно
    
    mask = (np.abs(z) > infinity_border) & (image == 0)
    # это означает следующее: мы находим все ячейки в матрице z, 
    # у которых модуль очень большой, и одновременно в соответствующей
    # ячейке в матрице image находится ноль
    
    image[mask] = k
    # заносим все найденные ячейки в image значение k
    # это аналог оператора if из предыдущей версии кода
    
    z[mask] = np.nan
    # те ячейки, про которые мы уже понимаем, что там 
    # z «ушло на бесконечность», мы не будем дальше обрабатывать
    # для этого вносим в них специальное значение np.nan
    # это поможет нам избежать ошибок переполнения
plt.xticks([])
plt.yticks([])
# выключим метки на осях
p=10
fig=plt.figure(figsize=(1*p,1*p))
plt.imshow(-image.T, cmap='ocean')